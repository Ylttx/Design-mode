# README
> 大话设计模式（C++实现）

[TOC]

## 第一章：简单工厂模式

* 计算器

## 第二章：策略模式
* 商场促销

## 第三章：单一职责原则

## 第四章：开放封闭原则

## 第五章：依赖倒转原则

## 第六章：装饰模式

* 穿衣服
特点：动态地给一个对象添加一些额外的指责，就增加功能来说，比子类灵活。
把类中的装饰功能从类中移除，简化原有的类。
* 类图

<img src="/Users/dllttx/Documents/learning/DesignMode/decorator/Decorator.svg" alt="Decorator" style="zoom:67%;" />

## 第七章：代理模式

## 第八章：工厂方法模式
* 学雷锋
优点：完全OCP，解决类简单工厂模式不但对扩展开放，对修改也开放的缺点
缺点：每加一个产品，就要一个产品工厂类，增加了开发工作量

## 第九章：原型模式

* 简单代码结构
* 不用重新初始化对象，而是动态地获得对象运行时的状态。

## 第十章： 模板方法模式

* 代码：考试试卷
* TemplateMethod：定义一个操作中算法的骨架，将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法中的某些特定步骤。
* 优点：去除子类中的重复代码；提供了一个很好的代码复用平台。

## 第十一章：迪米特法则

## 第十二章：外观模式

## 第十三章：建造者模式

* 代码：builder
* 建造者模式（生成器模式）将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
* Builer：为创建一个Product对象的各个部件指定的抽象接口。
* ConcreteBuilder：具体建造者，构建和装配各个部件。
* Director：构建一个使用Builder接口的对象。

## 第十四章：观察者模式

* 代码：observer
* 观察者模式（发布-订阅模式）
* 升级：委托事件技术

## 第十五章：抽象工厂模式

* Abstract Factory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
* 改进：简单工厂+反射+配置文件（参考google/fruit）

## 第十六章：状态模式

* 代码：state
* State：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
* 去掉if、switch等大量条件判断语句。

## 第十七章：适配器模式

* 将一个类的接口转换成客户希望的另外一个接口，使得原本不兼容的类可以一起工作
* 类适配器
* 对象适配器

## 第十八章：备忘录模式

* 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
* 应用：保存游戏进度、命令模式的撤销功能
* 代码：memento

## 第十九章：组合模式

* Composite：树形结构对象表示“部分——整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。
* 透明方式、安全方式
* 代码：composite

## 第二十章：迭代器模式（Iterator）

## 第二十一章：单例模式

* Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
* Double-Check Locking：双重锁定，保证多线程安全。
* 饿汉式单例类：静态初始化时实例化（提前占用系统资源）
* 饱汉式单例类：第一次被引用时实例化（处理线程安全）

## 第二十二章：桥接模式

* 合成/聚合复用原则（CARP）：尽量使用C/A，尽量不使用继承。
* Bridge：将抽象部分与它的实现部分分离，使它们可以独立地变化。

## 第二十三章：命令模式

* 将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。
* 优点：1、较容易地设计一个命令队列；2、易于记入日志；3、允许接收者决定是否否决请求；5、允许撤销、重做；6、扩展具体的命令类；7、把请求一个操作的对象与知道怎么执行一个操作的请求分割开。

## 第二十四章：指责链模式

* Chain of Responsibility
* 当客户提交；一个请求时，请求是沿着链传递直至有一个ConcreteHandler对象负责处理它。
* 简化对象的相互连接，它们仅需要保持一个指向其后继承的引用。
* 随时增加或修改处理请求的结构，灵活性好。